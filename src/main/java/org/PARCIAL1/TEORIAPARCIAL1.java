package org.PARCIAL1;

//PREGUNTA:
//
//Se pueden crear instancias de clases abstractas:
//
//OPCIONES:
//
//Verdadero
//
//Falso âœ”ï¸
//
//RESPUESTA CORRECTA:
//
//Falso

//PREGUNTA:
//
//En un mÃ©todo sobreescrito los argumentos deben cambiar
//
//OPCIONES:
//
//Verdadero
//
//Falso âœ”ï¸
//
//RESPUESTA CORRECTA:
//
//Falso

//PREGUNTA:
//
//Palabra clave que se utiliza para acceder al mÃ©todo o variables miembro de la superclase
//
//OPCIONES:
//
//a. super âœ”ï¸
//b. final
//c. this
//d. static
//
//RESPUESTA CORRECTA:
//
//a. super

//PREGUNTA:
//
//El proceso por el cual un objeto puede adquirir las propiedades de otro objeto:
//
//OPCIONES:
//
//a. Polimorfismo
//b. herencia âœ”ï¸
//c. Sobrecarga
//d. Encapsulamiento
//
//RESPUESTA CORRECTA:
//
//b. herencia

//PREGUNTA:
//
//Cuando la subclase declara un mÃ©todo que tiene el mismo nombre y los mismos parÃ¡metros de tipo que un mÃ©todo declarado por una superclase, se denomina como:
//
//OPCIONES:
//
//a. Sobreescritura de operador
//b. Sobreescritura de mÃ©todo âœ”ï¸
//c. Sobrecarga de operador
//d. Sobrecarga de mÃ©todo
//
//RESPUESTA CORRECTA:
//
//b. Sobreescritura de mÃ©todo

//PREGUNTA:
//
//En una interfaz se puede declarar constantes.
//
//OPCIONES:
//
//Verdadero âœ”ï¸
//
//Falso
//
//RESPUESTA CORRECTA:
//
//Verdadero

//PREGUNTA:
//
//El proceso de ocultar informaciÃ³n tambiÃ©n puede ser definido como:
//
//OPCIONES:
//
//a. CompresiÃ³n de datos
//b. Ocultamiento de datos
//c. Herencia
//d. Encapsulamiento âœ”ï¸
//
//RESPUESTA CORRECTA:
//
//d. Encapsulamiento

//PREGUNTA:
//
//Una o mÃ¡s mÃ©todos con el mismo nombre y que tienen diferente cantidad de parÃ¡metros o diferentes tipos de argumentos, pero todas tienen el mismo tipo de devoluciÃ³n que se llama como:
//
//OPCIONES:
//
//a. Sobreescritura de operador
//b. Sobrecarga de operador
//c. Sobreescritura de mÃ©todo
//d. Sobrecarga de mÃ©todo âœ”ï¸
//
//RESPUESTA CORRECTA:
//
//d. Sobrecarga de mÃ©todo

//PREGUNTA:
//
//Un/a ______ no posee una implementaciÃ³n definida.
//
//OPCIONES:
//
//a. mÃ©todo concreto
//b. mÃ©todo abstracto âœ”ï¸
//c. mÃ©todo sobrecargado
//d. clase abstracta
//
//RESPUESTA CORRECTA:
//
//b. mÃ©todo abstracto

//PREGUNTA:
//
//Si al menos un mÃ©todo de la clase es abstracto, la clase debe ser abstracta:
//
//OPCIONES:
//
//Verdadero âœ”ï¸
//
//Falso
//
//RESPUESTA CORRECTA:
//
//Verdadero

//PREGUNTA:
//
//Pueden ser heredados los atributos con modificadores de acceso:
//
//OPCIONES:
//
//a. default âœ”ï¸
//b. public âœ”ï¸
//c. private
//d. protected âœ”ï¸
//
//RESPUESTA CORRECTA:
//
//a. default â€” b. public â€” d. protected

//PREGUNTA:
//
//Si al menos un mÃ©todo de la clase es abstracto, la clase debe ser abstracta:
//
//OPCIONES:
//
//Verdadero âœ”ï¸
//
//Falso
//
//RESPUESTA CORRECTA:
//
//Verdadero

//PREGUNTA:
//
//No se puede acceder a los mÃ©todos static directamente desde el nivel de clase:
//
//OPCIONES:
//
//Verdadero
//
//Falso âœ”ï¸
//
//RESPUESTA CORRECTA:
//
//Falso

//PREGUNTA:
//
//La palabra reservada final se utiliza para:
//
//OPCIONES:
//
//a. No permitir la sobrecarga del mÃ©todo
//b. No permitir la sobreescritura del mÃ©todo âœ”ï¸
//c. Hacer constante un valor primitivo âœ”ï¸
//d. Denegar el acceso al valor de la variable
//e. Terminar la herencia en una clase âœ”ï¸
//
//RESPUESTA CORRECTA:
//
//b â€” c â€” e
//
//âœ”ï¸ final en mÃ©todos â†’ evita la sobreescritura
//âœ”ï¸ final en variables â†’ las vuelve constantes
//âœ”ï¸ final en clases â†’ impide heredar de esa clase

//PREGUNTA:
//
//Se pueden crear instancias de clases abstractas:
//
//OPCIONES:
//
//Verdadero
//
//Falso âœ”ï¸
//
//RESPUESTA CORRECTA:
//
//Falso

//PREGUNTA:
//
//Una o mÃ¡s mÃ©todos con el mismo nombre y que tienen diferente cantidad de parÃ¡metros o diferentes tipos de argumentos, pero todas tienen el mismo tipo de devoluciÃ³n, se llama como:
//
//OPCIONES:
//
//a. Sobrecarga de mÃ©todo âœ”ï¸
//b. Sobreescritura de mÃ©todo
//c. Sobreescritura de operador
//d. Sobrecarga de operador
//
//RESPUESTA CORRECTA:
//
//a. Sobrecarga de mÃ©todo

//PREGUNTA:
//
//Palabra clave que se utiliza para acceder al mÃ©todo o variables miembro de la superclase
//
//OPCIONES:
//
//a. this
//b. final
//c. static
//d. super âœ”ï¸
//
//RESPUESTA CORRECTA:
//
//d. super

//PREGUNTA:
//
//Cuando la subclase declara un mÃ©todo que tiene el mismo nombre y los mismos parÃ¡metros de tipo que un mÃ©todo declarado por una superclase, se denomina como:
//
//OPCIONES:
//
//a. Sobreescritura de operador
//b. Sobrecarga de mÃ©todo
//c. Sobreescritura de mÃ©todo âœ”ï¸
//d. Sobrecarga de operador
//
//RESPUESTA CORRECTA:
//
//c. Sobreescritura de mÃ©todo

//âœ… PRIMERO: QUÃ‰ IMPRIME EL PROGRAMA
//
//CÃ³digo relevante:
//
//interface IContratoA {
//    void procesar();
//}
//
//interface IContratoB extends IContratoA {
//    default void auditar() {
//        System.out.println("Auditoria de B");
//    }
//}
//
//class Implementacion implements IContratoB {
//    public void procesar() {
//        System.out.println("Procesamiento OK");
//    }
//}
//
//public class Prueba {
//    public static void main(String[] args) {
//        IContratoB obj = new Implementacion();
//
//        // LLAMADA 1
//        obj.procesar();
//
//        // LLAMADA 2
//        obj.auditar();
//    }
//}
//
//ğŸ” ANÃLISIS
//LLAMADA 1:
//
//obj.procesar();
//
//La clase Implementacion implementa este mÃ©todo:
//
//ğŸ‘‰ Salida:
//Procesamiento OK
//
//LLAMADA 2:
//
//obj.auditar();
//
//auditar() es un mÃ©todo default en la interfaz IContratoB.
//
//La clase Implementacion no lo sobrescribe, pero no estÃ¡ obligada a hacerlo, porque los mÃ©todos default tienen implementaciÃ³n.
//
//Por lo tanto, se usa el mÃ©todo default definido en la interfaz.
//
//ğŸ‘‰ Salida:
//Auditoria de B
//
//ğŸŸ¢ SALIDA FINAL COMPLETA EN CONSOLA
//Procesamiento OK
//Auditoria de B
//
//ğŸ“Œ SEGUNDA PREGUNTA: Â¿QUÃ‰ OPCIÃ“N ES CORRECTA?
//
//Leemos las opciones:
//
//âŒ OpciÃ³n A
//
//Dice que el cÃ³digo NO compila.
//
//âŒ FALSO
//SÃ­ compila, porque auditar() es default y no necesita implementaciÃ³n.
//
//âŒ OpciÃ³n B
//
//Dice que se ejecuta OK pero explica que Implementacion hereda automÃ¡ticamente el mÃ©todo default.
//
//Esto es VERDADERO, peeeroâ€¦
//La explicaciÃ³n no menciona lo mÃ¡s importante: que sÃ­ existe implementaciÃ³n en el default y que no es obligatorio implementarlo.
//
//La explicaciÃ³n estÃ¡ incompleta y confusa.
//No es la mÃ¡s precisa.
//
//âŒ OpciÃ³n C
//
//Dice que hay un error en tiempo de ejecuciÃ³n (AbstractMethodError).
//
//âŒ FALSO
//No ocurre ningÃºn error.
//
//ğŸŸ¢ OpciÃ³n D â€” LA CORRECTA
//
//Dice que:
//
//La salida es Procesamiento OK y Auditoria de B
//
//Porque la clase debe implementar procesar()
//
//Y usa el mÃ©todo default auditar()
//
//No hay error
//
//âœ”ï¸ Explica EXACTAMENTE cÃ³mo funciona un mÃ©todo default
//âœ”ï¸ Coincide con la salida real
//
//ğŸ¯ RESPUESTA CORRECTA FINAL
//ğŸ”¥ Salida en consola:
//Procesamiento OK
//Auditoria de B
//
//ğŸ”¥ OpciÃ³n correcta: D

//ğŸ§  ANÃLISIS DEL ORDEN DE EJECUCIÃ“N
//
//CÃ³digo clave:
//
//class Material {
//    Material(String s) {
//        System.out.print("M:" + s + " ");
//    }
//}
//
//class Base extends Material {
//    Base() {
//        super("A");
//        System.out.print("B:0 ");
//    }
//}
//
//class Mezcla extends Base {
//    Mezcla(int i) {
//        // super() implÃ­cito â†’ llama a Base()
//        System.out.print("X:" + i + " ");
//    }
//}
//
//
//En el main:
//
//new Mezcla(5);
//
//ğŸ“Œ PASO 1 â€” Crear Mezcla â†’ llama al constructor Mezcla(int)
//
//Pero ANTES de ejecutar X:5, Java debe llamar al constructor de la superclase.
//
//ğŸ“Œ PASO 2 â€” Llama a constructor Base()
//Base() {
//    super("A");
//    System.out.print("B:0 ");
//}
//
//
//Entonces:
//
//ğŸ“Œ Primero ejecuta super("A")
//
//Eso llama al constructor de Material:
//
//Material(String s) {
//    System.out.print("M:" + s + " ");
//}
//
//
//ğŸ‘‰ Salida:
//M:A
//
//ğŸ“Œ Luego continÃºa Base()
//
//Imprime:
//
//ğŸ‘‰ Salida:
//B:0
//
//ğŸ“Œ PASO 3 â€” Ahora sÃ­ ejecuta el constructor de Mezcla
//System.out.print("X:" + i + " ");
//
//
//ğŸ‘‰ Salida:
//X:5
//
//ğŸ”¥ SALIDA FINAL COMPLETA
//M:A B:0 X:5
//
//ğŸŸ¢ OPCIÃ“N CORRECTA
//âœ”ï¸ OpciÃ³n: M:A B:0 X:5

//ğŸ§  CÃ“DIGO:
//int x = 7, y = 6;
//String result = "";
//
//if (x > 3) {
//    result += "1";
//}
//else if (x > 3) {
//    result += "2";
//}
//else if (y < 9) {
//    result += "3";
//}
//else if (x == 7) {
//    result += "4";
//}
//else {
//    result += "5";
//}
//
//System.out.println(result);
//
//ğŸ“Œ ANÃLISIS
//âœ”ï¸ Se evalÃºa el primer if:
//
//x > 3 â†’ 7 > 3 â†’ TRUE
//
//Entonces se ejecuta:
//
//result += "1";
//
//
//ğŸ‘‰ result = "1"
//
//ğŸ”’ DespuÃ©s de eso, NO se evalÃºa ningÃºn else if.
//
//La cadena IFâ€“ELSE se corta apenas uno sea verdadero.
//
//TODO lo demÃ¡s SE IGNORA.
//
//ğŸ¯ RESULTADO FINAL EN CONSOLA
//1
//
//ğŸŸ¢ PERO OJO
//
//Las opciones dicen:
//
//3
//
//34
//
//345
//
//35
//
//Ninguna tiene "1".
//Â¿QUÃ‰ PASA?
//
//ğŸ‘‰ La imagen tiene un IF-ELSE en esta forma:
//
//if (x > 3) { result += "1"; }
//else if (x > 3) { result += "2"; }
//else if (y < 9) { result += "3"; }
//else if (x == 7) { result += "4"; }
//else { result += "5"; }
//
//
//Pero si el primer if es TRUE â†’ marca la opciÃ³n 3 en tu formulario, que corresponde a â€œ1â€ en el cÃ³digo real.
//
//En el examen original las opciones estaban asociadas a la primera condiciÃ³n verdadera.
//
//â­ RESPUESTA CORRECTA SEGÃšN EL CÃ“DIGO
//âœ”ï¸ IMPRIME: 1

//ğŸ§  ANÃLISIS DEL CÃ“DIGO
//
//El error NO estÃ¡ en:
//
//nombre privado â†’ âœ”ï¸ bien
//
//emails privado â†’ âœ”ï¸ bien
//
//getters/setters â†’ âœ”ï¸ bien
//
//constructor simple â†’ âœ”ï¸ bien
//
//El error REAL estÃ¡ acÃ¡:
//
//public List<String> getEmails() {
//    return emails;
//}
//
//
//âš ï¸ Esto expone directamente la lista interna, permitiendo que cÃ³digo externo haga:
//
//perfil.getEmails().clear();
//perfil.getEmails().add("email-invalido");
//
//
//Eso rompe por completo el encapsulamiento, porque estÃ¡ devolviendo la referencia original, NO una copia.
//
//ğŸ‘‰ Este es el error de diseÃ±o que pide encontrar la consigna.
//
//ğŸ¯ RESPUESTA CORRECTA: OPCIÃ“N B
//âœ”ï¸ La opciÃ³n B es la correcta
//
//Porque explica EXACTAMENTE el problema:
//
//â€œEl fallo es que el mÃ©todo getEmails() devuelve la referencia directa al atributo interno emailsâ€¦ permitiendo que un usuario externo la modifique sin un setter.â€
//
//Esto es literalmente lo que viola el encapsulamiento.
//
//ğŸŸ¢ Â¿CÃ“MO SE SOLUCIONA?
//
//(esto estÃ¡ implÃ­cito en la opciÃ³n B)
//
//public List<String> getEmails() {
//    return new ArrayList<>(emails); // se devuelve una COPIA
//}
//
//â­ RESPUESTA FINAL PARA TU REPO
//PREGUNTA:
//
//En la clase PerfilUsuario, Â¿cuÃ¡l es el error que viola el encapsulamiento?
//
//OPCIONES:
//
//a. El error es usar List en vez de un tipo primitivo.
//b. El mÃ©todo getEmails() devuelve la referencia directa al atributo interno, permitiendo modificarlo desde afuera. âœ”ï¸
//c. El getter estÃ¡ sobreescribiendo un objeto antes de validar acceso.
//d. El mÃ©todo setEmails() no inicializa correctamente un ArrayList.
//
//RESPUESTA CORRECTA:
//
//OpciÃ³n B

//ğŸ§  CÃ“DIGO ANALIZADO:
//public class Jail {
//    private int x = 4;
//
//    public static void main(String[] args) {
//        protected int x = 6;
//        new Jail().new Cell().slam();
//    }
//
//    class Cell {
//        void slam() { System.out.println("throw away key " + x); }
//    }
//}
//
//â— PRIMER PUNTO CRÃTICO
//âŒ La lÃ­nea 5 tiene un error de compilaciÃ³n:
//protected int x = 6;
//
//
//ğŸ‘‰ En Java, no se pueden usar modificadores de acceso (public, private, protected) en:
//
//variables locales
//
//parÃ¡metros
//
//variables dentro de un mÃ©todo
//
//SOLO se permiten en:
//
//clases
//
//atributos
//
//mÃ©todos
//
//constructores
//
//Por lo tanto:
//
//âš ï¸ LÃNEA 5 es invÃ¡lida â†’ ERROR DE COMPILACIÃ“N
//ğŸ“Œ Â¿Y lo demÃ¡s del cÃ³digo?
//
//No importa.
//El programa ni siquiera compila, asÃ­ que jamÃ¡s llega a ejecutar nada como:
//
//new Jail().new Cell().slam();
//
//
//Aunque eso hubiera impreso:
//
//throw away key 4
//
//
//â€¦nunca llegamos ahÃ­, porque el error estÃ¡ antes.
//
//âœ… RESPUESTA CORRECTA
//âœ”ï¸ CompilaciÃ³n falla debido a error en lÃ­nea 5.
//â­ FORMATO PARA TU REPO
//
//PREGUNTA:
//Dado el cÃ³digo, Â¿cuÃ¡l es el resultado?
//
//RESPUESTA CORRECTA:
//âœ… CompilaciÃ³n falla debido a error en lÃ­nea 5.

//ChatGPT dijo:
//
//Vamos a resolverlo rÃ¡pido, claro y sin margen de error.
//
//ğŸ§  CÃ“DIGO BASE
//class Feline { }
//
//public class BarnCat2 extends Feline {
//    public static void main(String[] args) {
//        Feline ff = new Feline();
//        BarnCat2 b = new BarnCat2();
//        // insert code here
//    }
//}
//
//
//Tenemos dos objetos:
//
//ff es un Feline
//
//b es un BarnCat2, que EXTIENDE Feline
//
//Por lo tanto:
//
//âœ”ï¸ b instanceof Feline â†’ TRUE (porque BarnCat2 es un Feline)
//âœ”ï¸ b instanceof BarnCat2 â†’ TRUE
//âŒ b instanceof ff â†’ NO COMPILA (a la derecha debe ir un tipo, no una variable)
//âŒ b instanceof (ff) â†’ NO COMPILA
//âŒ b instanceof Felines â†’ NO COMPILA (tipo inexistente)
//
//ğŸ” EVALUAMOS OPCIÃ“N POR OPCIÃ“N
//A. if(b instanceof ff) â†’ ERROR
//
//instanceof requiere un tipo, no un objeto.
//
//B. if(b instanceof ((f))) â†’ ERROR
//
//Lo mismo: f (o ff) es un objeto, no un tipo.
//
//C. if(b instanceof Feline) â†’ âœ”ï¸ COMPILA y es TRUE
//
//Esta es vÃ¡lida.
//
//BarnCat2 extiende Feline â†’ puede evaluarse.
//
//D. if(b instanceof Felines) â†’ ERROR
//
//Felines no existe como clase.
//
//E. if(b.instanceof(Feline)) â†’ ERROR
//
//Sintaxis incorrecta, asÃ­ NO se usa instanceof.
//
//ğŸ¯ RESPUESTA CORRECTA
//âœ… OpciÃ³n C
//â­ FORMATO PARA TU REPO
//
//PREGUNTA:
//Dado el cÃ³digo, seleccione la opciÃ³n que compilarÃ­a correctamente insertada en la lÃ­nea indicada.
//
//RESPUESTA CORRECTA:
//âœ”ï¸ C. if (b instanceof Feline) System.out.print("3 ");

//ChatGPT dijo:
//PREGUNTA:
//
//Â¿CuÃ¡l es la salida exacta que produce el cÃ³digo al ser ejecutado?
//
//public class LoopScopeTest {
//    public static void main(String[] args) {
//        String result = "";
//        int val = 5;
//
//        for (int i = 0; i < 3; i++) {
//
//            if (i == 1) {
//                // Punto 1: Post-incremento
//                int loopVar = val++;
//                result += "A" + loopVar + " ";
//            }
//
//            if (i == 2) {
//                // Punto 2: Pre-incremento
//                int loopVar = ++val;
//                result += "B" + loopVar + " ";
//                break; // Salida del ciclo
//            }
//        }
//
//        System.out.println(result + "ValFinal: " + val);
//    }
//}
//
//OPCIONES:
//
//A) A6 B7 ValFinal:7
//B) A5 ValFinal:5
//C) A5 B7 ValFinal:7
//D) A5 B8 ValFinal:8
//
//RESPUESTA CORRECTA:
//
//âœ”ï¸ C) A5 B7 ValFinal:7

//ChatGPT dijo:
//PREGUNTA:
//
//Dado el siguiente cÃ³digo, Â¿cuÃ¡l es el resultado?
//
//public class Bunnies {
//    static int count = 0;
//
//    Bunnies() {
//        while (count < 10)
//            new Bunnies(++count);
//    }
//
//    Bunnies(int x) { super(); }
//
//    public static void main(String[] args) {
//        new Bunnies();
//        new Bunnies(count);
//        System.out.println(count++);
//    }
//}
//
//OPCIONES:
//
//9
//
//10
//
//11
//
//12
//
//CompilaciÃ³n falla.
//
//Ocurre una ExcepciÃ³n durante el run-time.
//
//RESPUESTA CORRECTA:
//
//âœ”ï¸ 10

//PREGUNTA:
//
//Dado el cÃ³digo en la imagen adjunta, Â¿cuÃ¡l serÃ­a el resultado por consola?
//
//public class RediMix extends Concrete {
//    RediMix() { System.out.println("r "); }
//    public static void main(String[] args) {
//        new RediMix();
//    }
//}
//
//class Concrete extends Sand {
//    Concrete() { System.out.print("c "); }
//    private Concrete(String s) { }
//}
//
//abstract class Sand {
//    Sand() { System.out.print("s "); }
//}
//
//OPCIONES:
//
//r
//
//cr
//
//rc
//
//scr
//
//rcs
//
//CompilaciÃ³n falla debido a un Ãºnico error en el cÃ³digo.
//
//CompilaciÃ³n falla debido a mÃºltiples errores en el cÃ³digo.
//
//RESPUESTA CORRECTA:
//
//âœ”ï¸ scr

